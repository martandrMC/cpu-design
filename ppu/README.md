# Puny Processing Unit

### Overview

The Puny Processing Unit is a minimal Turning-complete harvard architecture with a data word size of 8 bits and an instruction word size of 10 bits. It can address a maximum of 64 instruction words and 16 data words of memory, hence its name.

### Project Layout

- The [assembler](assembler) directory contains the assembler for the processor written in Java.
- The [examples](examples) directory contains a few example programs written in the processor's assembly language.
- [PPU.cpj](PPU.cpj) is the processor implemented in [LogicCircuit](https://www.logiccircuit.org/) simulator.
- [ppuasm.xml](ppuasm.xml) is a Notepad++ UDL for the processor's assembly language.

## Register System

The processor has 4 general purpose registers ( *A*, *B*, *C*, and *D* ) and can select up to 2 of them in each instruction. Unlike other systems where one of the two registers specified is used both as a source and a destination, the PPU uses one register as the destination, one as a source, and for binary operations like addition the second source is implied to be register A. Unary operations like bit shifts do not need a second source.  
  
There also exist 2 special purpose registers, the PC ( *Program Counter* )  that keeps track of the currently executing instruction, and the flags register that holds metadata about calculation results that get used as conditions for branching. The PC can be read through a dedicated instruction and get stored in a general purpose register but the flags register can not.

### Register Useages

- ***Program Counter*** : Points to currently executing instruction. Can be via branch instructions.
- ***Flags Register*** : Holds flags from the last executed ALU operation. Can not be directly acessed.
- ***A Register*** : The implied second source register.
- ***B Register*** : The only register that can be used to address data memory.
- ***C Register*** : General purpose register.
- ***D Register*** : General purpose register. ( *Recommended register for holding function return addresses.* )

### Flags

Flags are stored in their own specific register and are generated by the ALU. There exist 4 in total :
- ***True*** : Will always be 1. Allows for unconditional jumps.
- ***Zero*** : Set when the ALU's result is equal to 0. Reset otherwise.
- ***Carry*** : Set when the ALU's result can not fit in 8 bits ( *unsigned* ) or contains the bit that a shift instruction removed.
- ***Overflow*** : Set when the ALU's result can not fit in 8 bits ( *signed* ) .

## Instruction Set

### Instruction Types

There exist 31 different instructions each of which is in one of the following 4 types.

OPC indicates an opcode group, IMM indicates an immediate value group, REG,DST and SRC indicate a register address except DST is always the destination register and SRC the source register while REG can be both depending on the specific instruction. 

| Name  | G4 | G3 | G2 | G1 | G0 |
| :-: | :-: | :-: | :-: | :-: | :-: |
| S | OPC | OPC | REG | IMM | IMM |
| L | OPC | OPC | IMM | IMM | IMM |
| R | OPC | OPC | OPC | DST | SRC |
| N | OPC | OPC |  -  |  -  |  -  |
##### *Note*: `Gx` indicates a 2-bit grouping

### Main Instruction Table

| G4/G3 | Type | Mnemonic | Operation | Description |
| :-: | :-: | :-: | :-: | :- |
| 0000 | S | LDI | REG = IMM | Load IMM to REG |
| 0001 | S | LDM | REG = (IMM) | Load value from data memory at IMM to REG |
| 0010 | S | STM | (IMM) = REG | Store REG to data memory at IMM |
| 0011 | R | - | *Extd Moves* | *Refer to auxiliary table 1* |
| 0100 | S | ADI | REG = A + IMM | Add IMM to content of register A and store to REG |
| 0101 | S | SBI | REG = A - IMM | Subtract IMM from content of register A and store to REG |
| 0110 | R | - | *Reg Arithmetic* | *Refer to auxiliary table 2* |
| 0111 | R | - | *Reg Bitwise Logic* | *Refer to auxiliary table 3* |
| 1000 | L | JTI | PC = IMM | Jump to program address IMM always |
| 1001 | L | JCI | Cf ? PC = IMM | Jump to program address IMM if the Carry flag is set |
| 1010 | L | JVI | Vf ? PC = IMM | Jump to program address IMM if the Overflow flag is set |
| 1011 | L | JZI | Zf ? PC = IMM | Jump to program address IMM if the Zero flag is set |
| 1100 | R | - | *Reg Branching* | *Refer to auxiliary table 4* |
| 1101 | R | - | *Misc Calculations* | *Refer to auxiliary table 5* |
| 1110 | N | HLT | - | Stop Execution |
| 1111 | N | NOP | - | No Operation |

### Auxiliary Instruction Table 1: Extended Moves

| G2 | Mnemonic | Operation | Description |
| :-: | :-: | :-: | :- |
| 00 | LDR | DST = (B) | Load value from data memory at B to DST |
| 01 | STR | (B) = SRC | Store SRC to data memory at B |
| 10 | MOV | DST = SRC | Overwrite DST with the value of SRC |
| 11 | LDP | DST = PC+1 | Overwrite DST with the value of PC+1 |

### Auxiliary Instruction Table 2: Register Arithmetic

| G2 | Mnemonic | Operation | Description |
| :-: | :-: | :-: | :- |
| 00 | ADD | DST = A + SRC | Add SRC with A and store to DST |
| 01 | ADC | DST = A + SRC + Cf | Add SRC with A and Cf and store to DST |
| 10 | SUB | DST = A - SRC | Subtract SRC from A and store to DST |
| 11 | SBC | DST = A - SRC - !Cf | Subtract SRC and !Cf from A and store to DST |

### Auxiliary Instruction Table 3: Register Bitwise Logic

| G2 | Mnemonic | Operation | Description |
| :-: | :-: | :-: | :- |
| 00 | AND | DST = A & SRC | Bitwise AND A and SRC and store to DST |
| 01 | IOR | DST = A \| SRC | Bitwise OR A and SRC and store to DST |
| 10 | NOR | DST = ~(A \| SRC) | Bitwise NOR A and SRC and store to DST |
| 11 | XOR | DST = A ^ SRC | Bitwise XOR A and SRC and store to DST |

### Auxiliary Instruction Table 4: Register Branching

| G2 | Mnemonic | Operation | Description |
| :-: | :-: | :-: | :- |
| 00 | JTR | PC = SRC | Jump to program address SRC always |
| 01 | JCR | Cf ? PC = SRC | Jump to program address IMM if the Carry flag is set |
| 10 | JVR | Vf ? PC = SRC | Jump to program address IMM if the Overflow flag is set |
| 11 | JZR | Zf ? PC = SRC | Jump to program address IMM if the Zero flag is set |

### Auxiliary Instruction Table 5: Miscellaneous Calculations

| G2 | Mnemonic | Operation | Description |
| :-: | :-: | :-: | :- |
| 00 | RSH | DST = SRC >> 1 | Logical Right Shift SRC and store to DST |
| 01 | RSC | DST = {Cf,SRC} >> 1 | Rotate Right through Carry SRC and store to DST |
| 10 | NND | DST = ~(A & SRC) | Bitwise NAND A and SRC and store to DST |
| 11 | NPL | DST = A & ~SRC | Bitwise NIMPLY A and SRC and store to DST |
